---
title: With and without ESP
format:
  html:
    code-fold: true
    code-overflow: wrap
    embed-resources: true
execute:
  warning: false
engine: knitr
jupyter:
  kernelspec:
    display_name: R
    language: R
    name: ir
---

```{r}
#| output: false

# Setup-------------------------------------
date()

try(rm(list = ls()))

here::i_am("notebooks/model_results_analysis_example.qmd")

# Load libraries
pkgs <-
  c(
    "here",
    "tidyverse",
    "readxl",
    "gtsummary",
    "gt",
    "survival",
    "ggsurvfit",
    "cowplot",
    "kableExtra",
    "reticulate",
    "paletteer",
    "viridis",
    "janitor", #for cleaning names
    "gtExtras" #for making plots in gt tables
  )
sapply(pkgs, library, character.only = TRUE)

use_condaenv("py3") #adapt to conda environment

# Set Python's working directory to match R's
os <- import("os")
os$chdir(here())

# set paths
knitr::opts_knit$set(root.dir = here())
input_path <- "res/"
output_path <- "res/figures/"

# set theme
element_text_size <- 6
theme_nassim <- function(base_size = element_text_size) {
    font <- "Arial"
    theme_minimal(base_size = base_size) %+replace%
        theme(
            # changed theme options
        )
}
# Changing the default theme
theme_set(theme_nassim())

# set color palette
n2_palette <- paletteer_d("wesanderson::Darjeeling2")[c(2, 3)]
```

```{r}
MedianIQR <- function(x,
                      nsmall = 1,
                      na.rm = TRUE,
                      percentage = FALSE,
                      big.mark = ",",
                      trim = TRUE,
                      ...) {
  median_val <- format(
    median(x, na.rm = na.rm),
    big.mark = big.mark,
    nsmall = nsmall,
    trim = trim,
    ...
  )
  q1_val <- format(
    quantile(x, 0.25, na.rm = na.rm),
    big.mark = big.mark,
    nsmall = nsmall,
    trim = trim,
    ...
  )
  q2_val <- format(
    quantile(x, 0.75, na.rm = na.rm),
    big.mark = big.mark,
    nsmall = nsmall,
    trim = trim,
    ...
  )
  
  if (percentage) {
    paste0(median_val, "% [", q1_val, "%, ", q2_val, "%]")
  }
  else{
    paste0(median_val, " [", q1_val, ", ", q2_val, "]")
  }
}

clean_var_names <- list(
    "pts_on_waiting_list" ~ "Pts on Waiting List",
    "pts_transplantable" ~ "Pts Transplantable",
    "percentage_transplantable" ~ "Percentage Transplantable",
    "pts_transplanted" ~ "Pts Transplanted",
    "pts_removed" ~ "Pts Removed",
    "living_donor_transplanted" ~ "Living Donor Transplanted",
    "et_program" ~ "ET Program",
    "age_gap" ~ "Age Gap",
    "age_donor" ~ "Age Donor",
    "age_recipient" ~ "Age Recipient",
    "vpra" ~ "vPRA",
    "vpra_group" ~ "vPRA",
    "recipient_age_group" ~ "Recipient Age Group",
    "donor_age_group" ~ "Donor Age Group",
    "blood_group_recipient" ~ "Recipient Blood Group",
    "blood_group_donor" ~ "Donor Blood Group",
    "hla_mm" ~ "HLA MM",
    "region_recipient" ~ "Recipient Region",
    "region_donor" ~ "Donor Region",
    "allocation_region_type" ~ "Allocation Region Type",
    "declined_offers" ~ "Declined Offers",
    "more_than5_declined_offers" ~ "More than Five Declined Offers"
)

build_named_vector <- function(formula_list) {
    setNames(
        sapply(formula_list, function(f) as.character(f[[3]])), # RHS
        sapply(formula_list, function(f) as.character(f[[2]])) # LHS
    )
}

filter_labels_by_vars <- function(var_labels_formula_list, filter_vars) {
    var_labels_formula_list[sapply(var_labels_formula_list, function(x) x[[2]] %in% filter_vars)]
}
```

## Introduction

Aim is to compare multiple runs of a model to the data from the registry data.

Step size and steps have to be set according to the parameters chosen for the model.

```{r}
step_size <- 1/36
steps <- (0:11)/step_size

df_dts <- read.csv(here(input_path, "multi_alternate_models_merged_patients_donor_esp_false_true.csv")) %>%
  mutate(
    model_name = if_else(model_esp_age_border == 65, "No Changes", "ESP Omitted"),
    model_esp_age_border = as.factor(model_esp_age_border),
    et_program = case_when(
      et_program == "esp" ~ "ESP",
      et_program == "etkas" ~ "ETKAS",
      .default = et_program
    ),
    region_recipient = str_to_title(str_replace_all(region_recipient, "_", "-")),
    region_donor = str_to_title(str_replace_all(region_donor, "_", "-"))
  ) %>% 
  mutate(model_name = factor(model_name, levels = c("No Changes", "ESP Omitted")))

df_dts_summary <- read.csv(here(input_path, "multi_alternate_models_data_esp_false_true.csv")) %>% 
  mutate(model_name = if_else(model_esp_age_border == 65, "No Changes", "ESP Omitted")) %>% 
   mutate(model_name = factor(model_name, levels = c("No Changes", "ESP Omitted")))
```

Modifying the agent based model data.

A new column is added to get an insight, if an organ is allocated in the same region or nationwide. As values "Regional" and "Home country" are used, since these values are also in the registry data possible (beside "Abroad").

```{r}
df_dts <- df_dts %>% 
  mutate(allocation_region_type = if_else(region_recipient == region_donor, "Regional", "Home country"))
```

## Waiting list development

### Model Data

Numbers per year are calculated for each model run.

```{r}
df_dts_summary <- df_dts_summary %>%
  group_by(model_seed, model_name) %>% 
  mutate(date = as.Date("2006-01-01") + years(step), .before = "pts_on_waiting_list") %>%
  mutate(
    removed_pat_per_year = pts_removed - lag(pts_removed, default = 0),
    pts_transplanted_per_year = pts_transplanted - lag (pts_transplanted, default = 0),
    living_donor_transplanted_per_year = living_donor_transplanted - lag (living_donor_transplanted, default = 0)
    ) %>% 
  ungroup() %>% 
  select(-c(step, X))
```

Median and IQR over all model runs are calculated

```{r}
df_dts_summary <- df_dts_summary %>% 
  group_by(model_name, date) %>%
  summarise(across(-c(model_run_id, model_seed, model_esp_age_border), list(median = median,
                                                      q025 = ~quantile(.x, 0.025),
                                                      q975 = ~quantile(.x, 0.975),
                                                      q1 = ~quantile(.x, 0.25),
                                                      q3 = ~quantile(.x, 0.75),
                                                      medianiqr = ~ MedianIQR(.x, nsmall = 0)
                                                      ), .names = "{.col}__{.fn}")) %>% 
  ungroup()
```

```{r}
df_long <- df_dts_summary %>%
  select(-contains("per_year")) %>% 
  rename(pts_on_waiting_list = pts_on_waiting_list__median,
         pts_transplantable = pts_transplantable__median,
         pts_transplanted = pts_transplanted__median,
         pts_removed = pts_removed__median,
         living_donor_transplanted = living_donor_transplanted__median) %>%
  pivot_longer(
    cols = c(
      pts_on_waiting_list,
      pts_transplantable,
      pts_transplanted,
      pts_removed,
      living_donor_transplanted
    ),
    names_to = "variable",
    values_to = "median"
  ) %>%
  mutate(q025 = NA,
         q1 = NA,
         q3 = NA,
         q975 = NA) %>% 
  mutate(across(c(q025, q1, q3, q975), ~ case_when(
  variable == "pts_on_waiting_list" ~ get(paste0("pts_on_waiting_list__", cur_column())),
  variable == "pts_transplantable" ~ get(paste0("pts_transplantable__", cur_column())),
  variable == "pts_transplanted" ~ get(paste0("pts_transplanted__", cur_column())),
  variable == "pts_removed" ~ get(paste0("pts_removed__", cur_column())),
  variable == "living_donor_transplanted" ~ get(paste0("living_donor_transplanted__", cur_column()))
))) %>% 
  select(-ends_with(c("__q025", "__q975", "__q1", "__q3"))) %>% 
  mutate(variable = case_match(variable, !!!clean_var_names))

end_date <- as.Date("2017-01-01")
end_values <- df_long %>% 
  filter(date == end_date) %>%
  select(date, model_name, variable, median) %>% 
  pivot_wider(values_from = median, names_from = model_name, names_prefix = "median") %>% 
  group_by(variable) %>%
  summarise(perc_difference = `medianESP Omitted`/`medianNo Changes`*100-100,
            `medianESP Omitted` = `medianESP Omitted`,
            `medianNo Changes` = `medianNo Changes`,
            .groups = "drop")

plot_model_development <- ggplot(df_long, aes(x = date)) +
  geom_line(aes(y = median, color = model_name)) +
  geom_linerange(aes(
      ymin = q1,
      ymax = q3,
      color = model_name
    )) +
  scale_color_manual(values = n2_palette, name = "Model") +
  scale_x_date(breaks = as.Date(c("2006-01-01", "2011-01-01", "2016-01-01")), labels = c("2006", "2011", "2016"), minor_breaks = "1 year") +
  ylab(label = "Count") +
  xlab(label = "Year") +
  facet_wrap(~variable) +
  theme(legend.position = c(1, 0),
        legend.justification = c(0.95, 0)) +
  geom_text(
    data = end_values,
    aes(
      x = end_date,
      y = pmax(`medianESP Omitted`, `medianNo Changes`, na.rm = TRUE),
      label = paste0("Diff: ", round(perc_difference, 2), "%")
    ),
    hjust = 1,
    vjust = -0.2,
    size = rel(0.8) * .pt,
    color = "grey30"
  ) +
  coord_cartesian(clip = "off")

plot_model_development
```

### Model deviance

Comparing the different models at the end date "2017-01-01"

```{r}
df_dts_summary %>%
  filter(date == as.Date("2017-01-01")) %>%
  select(-contains("medianiqr")) %>%
  pivot_longer(
    cols = -c(date, model_name),
    names_to = c("variable", "stat_type"),
    names_sep = "__",
    values_to = "value"
  ) %>%
  pivot_wider(names_from = variable, values_from = value) %>%
  unite(model_name, stat_type, col = "model_name") %>%
  select(-c(date, contains("per_year"))) %>%
  column_to_rownames(var = "model_name") %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "variable") %>%
  mutate(across(
    c(
      "ESP Omitted_median",
      "No Changes_median"
    ),
    ~
      paste0(
        format(.x, big.mark = ",", trim = TRUE),
        " (",
        format(get(str_replace(paste0(cur_column(
        )), "median", "q1")), big.mark = ",", trim = TRUE),
        "–",
        format(get(str_replace(paste0(cur_column(
        )), "median", "q3")), big.mark = ",", trim = TRUE),
        ")"
      )
  )) %>%
  select(-contains(c("q1", "q3", "q025", "q975"))) %>%
  mutate(variable = case_match(variable, !!!clean_var_names, .default = variable)) %>%
  gt() %>%
  cols_label_with(columns = c(-variable),
                  ~ str_replace(., "_median", "")) %>%
  cols_label("variable" ~ "Variable") %>%
  tab_spanner(label = "Model",
              columns = contains("median"))
```

Filter for transplanted patients.

```{r}
df_postmortem <- df_dts %>%
  filter(agent_type == "patient" &
           status_recipient == "transplanted") %>%
  rename(list_to_tx_time = waitinglist_time, dialysis_to_tx_time = dialysis_time) %>%
  mutate(
    recipient_age_group = case_when(
      age_recipient < 18 ~ "<18",
      age_recipient >= 18 & age_recipient < 65 ~ "18-64",
      age_recipient >= 65 ~ ">=65"
    ),
    donor_age_group = case_when(
      age_donor < 18 ~ "<18",
      age_donor >= 18 & age_donor < 65 ~ "18-64",
      age_donor >= 65 ~ ">=65"
    ),
    age_gap = age_recipient - age_donor,
    more_than5_declined_offers = if_else(declined_offers > 5, TRUE, FALSE),
    vpra_group = case_when(
      vpra == 0 ~ "0%",
      vpra > 0 & vpra < 85 ~ ">0%-<85%",
      vpra >= 85 ~ ">=85%"
    )
  ) %>% 
  mutate(recipient_age_group = factor(recipient_age_group, levels = c("<18", "18-64", ">=65")),
         donor_age_group = factor(donor_age_group, levels = c("<18", "18-64", ">=65")),
         vpra_group = factor(vpra_group, levels = c("0%", ">0%-<85%", ">=85%"))
         )
```

All model runs are combined and compared.

```{r}
stats_multi_run <- function(data, full_data, variable, ...) {
  #' this function first calculates the percentage of each level within each model run,
  #' and then the median (IQR) across model runs
  dots <- list(...)
  variable_name <- variable
  by_vars <- dots$by #holds the current variable name and the 'by' variable name
  
  # Recover by + variable columns via index
  # this detour is necessary since the levels aren't accessible anymore 
  # in gtsummary version 2.1.0
  recovered_data <- left_join(data, full_data[c("index", by_vars)], by = "index")
  
  # Extract current level of the variable and by group
  current_level <- unique(recovered_data[[variable_name]])
  current_level_by <- unique(recovered_data[[by_vars[[1]]]])
  
  # Return NULL row if either level is missing
  if (length(current_level) == 0 | length(current_level_by) == 0) {
    return(
      tibble(
        multi_model_perc_median = NULL,
        multi_model_perc_q1 = NULL,
        multi_model_perc_q3 = NULL,
        multi_model_median = NULL,
        multi_model_q1 = NULL,
        multi_model_q3 = NULL
      )
    )
  }
  
  # Filter full_data for current 'by' level
  grouped_by_data <- filter(full_data, .data[[by_vars[[1]]]] == current_level_by)
  
  # Compute % stats
  tbl_median_iqr <- grouped_by_data %>%
    group_by(model_run_id) %>%
    summarise(ratio = mean(.data[[variable_name]] == current_level, na.rm = TRUE) * 100,
              .groups = "drop") %>%
    summarise(
      multi_model_perc_median = median(ratio),
      multi_model_perc_q1 = quantile(ratio, 0.25),
      multi_model_perc_q3 = quantile(ratio, 0.75),
      .groups = "drop"
    )
  
  # Compute count stats
  tbl_count <- data %>%
    count(model_run_id, name = "count") %>%
    summarise(
      multi_model_median = median(count),
      multi_model_q1 = quantile(count, 0.25),
      multi_model_q3 = quantile(count, 0.75),
      .groups = "drop"
    )
  
  bind_cols(tbl_count, tbl_median_iqr)
}
```

```{r}
tmp_include <- c(
  "recipient_age_group",
  "donor_age_group",
  "blood_group_recipient",
  "blood_group_donor",
  "vpra_group",
  "hla_mm",
  "region_recipient",
  "region_donor",
  "allocation_region_type"
)

categ_summary_tbl <- df_postmortem %>%
  mutate(index = row_number()) %>% # index is necessary for an access of the current level
  tbl_strata(
    strata = model_name,
    .tbl_fun = ~ tbl_custom_summary(
      .x,
      by = et_program,
      include = tmp_include,
      label = filter_labels_by_vars(clean_var_names, tmp_include),
      stat_fns = all_categorical() ~ stats_multi_run,
      statistic = all_categorical() ~ "{multi_model_perc_median}% [{multi_model_perc_q1}%–{multi_model_perc_q3}%]",
      digits = list(
        recipient_age_group ~ c(1, 1),
        donor_age_group ~ c(1, 1),
        blood_group_recipient ~ c(1, 1),
        blood_group_donor ~ c(1, 1),
        region_recipient ~ c(1, 1),
        region_donor ~ c(1, 1),
        allocation_region_type ~ c(1, 1),
        vpra_group  ~ c(1, 1),
        hla_mm ~ c(1,1)
      )
    )
  )

tmp_include <- c("age_gap", "age_donor", "age_recipient")

cont_summary_tbl <- df_postmortem %>%
  tbl_strata(strata = model_name,
             .tbl_fun =
               ~ tbl_summary(
                 .x,
                 by = et_program,
                 include = tmp_include,
                 label = filter_labels_by_vars(clean_var_names, tmp_include),
               ))

tbl_stack(list(cont_summary_tbl, categ_summary_tbl)) %>% 
  modify_footnote(all_stat_cols() ~ "For continuous variables, the median [IQR] is calculated across all pooled simulations. For categorical variables, the percentage is first calculated within each model run, and then the median 6IQR] across model runs is reported.")
```

```{r}
tmp_include <- c(
  "recipient_age_group",
  "donor_age_group",
  "blood_group_recipient",
  "blood_group_donor",
  "vpra_group",
  "hla_mm",
  "region_recipient",
  "region_donor",
  "allocation_region_type"
)

categ_summary_tbl <- df_postmortem %>%
  mutate(index = row_number()) %>% 
  tbl_custom_summary(
      by = model_name,
      include = tmp_include,
      label = filter_labels_by_vars(clean_var_names, tmp_include),
      stat_fns = all_categorical() ~ stats_multi_run,
      statistic = all_categorical() ~ "{multi_model_perc_median}% [{multi_model_perc_q1}%–{multi_model_perc_q3}%]",
      digits = list(
        recipient_age_group ~ c(1, 1),
        donor_age_group ~ c(1, 1),
        blood_group_recipient ~ c(1, 1),
        blood_group_donor ~ c(1, 1),
        region_recipient ~ c(1, 1),
        region_donor ~ c(1, 1),
        allocation_region_type ~ c(1, 1),
        vpra_group  ~ c(1, 1),
        hla_mm ~ c(1,1)
      )
    )

tmp_include <- c("age_gap", "age_donor", "age_recipient")

cont_summary_tbl <- df_postmortem %>%
  tbl_summary(
    by = model_name,
                 include = tmp_include,
                 label = filter_labels_by_vars(clean_var_names, tmp_include),
               )

tbl_stack(list(cont_summary_tbl, categ_summary_tbl)) %>% 
  modify_footnote(all_stat_cols() ~ "For continuous variables, the median [IQR] is calculated across all pooled simulations. For categorical variables, the percentage is first calculated within each model run, and then the median [IQR] across model runs is reported.")
```

## Age at transplant

The Median and IQR of all model runs are shown for the model graph.

```{r}
# Calculate median and IQR of counts across model_run_ids for each age_recipient
dts_counts <- df_postmortem %>%
  mutate(age_recipient_bin = floor(age_recipient)) %>%
  group_by(model_name, model_run_id, age_recipient_bin) %>%
  summarise(count = n(), .groups = "drop") %>% 
  group_by(model_name, age_recipient_bin) %>%
  summarise(
    median_count = median(count, na.rm = TRUE),
    q1_count = quantile(count, 0.25, na.rm = TRUE),
    q3_count = quantile(count, 0.75, na.rm = TRUE),
    sd_count = sd(count, na.rm = TRUE),
    .groups = "drop"
  )

plot_rec_age_dist <- ggplot(data = dts_counts,
                           aes(x = age_recipient_bin + 0.5, y = median_count, fill = model_name)) +
  geom_col(alpha = 0.6, width = 1) +
  geom_errorbar(
    data = dts_counts,
    aes(x = age_recipient_bin + 0.5, ymin = q1_count, ymax = q3_count),
    width = 0.5,
    color = "grey20",
    alpha = 0.8
  ) +
  facet_wrap(~ model_name) +
  ggtitle("Recipient Age Distribution") +
  xlab("Recipient Age (binned)") +
  ylab("Count") +
  theme(legend.position = "none") +
  scale_fill_manual(values = n2_palette)

plot_rec_age_dist
```

## Waiting time

All model runs are combined and the waiting times shown. The median is shown for the combined data.

```{r}
df_postmortem %>%
  ggplot(aes(y = list_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  facet_wrap(~ recipient_age_group) +
  scale_color_manual(values = n2_palette, name = NULL) +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("List to Transplant Time (years)")

df_postmortem %>% 
  ggplot(aes(y = list_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  facet_wrap(~ et_program) +
  scale_color_manual(values = n2_palette, name = NULL) +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("List to Transplant Time (years)")

df_postmortem %>% 
  ggplot(aes(y = list_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  scale_color_manual(values = n2_palette, NULL) +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("List to Transplant Time (years)")
```

```{r}
plot_dial_to_tx_time_by_age <- df_postmortem %>%
  ggplot(aes(y = dialysis_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  facet_wrap(~ recipient_age_group) +
  scale_color_manual(values = n2_palette, name = "Model") +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("Dialysis to Transplant Time (years)")

plot_dial_to_tx_time_by_program <- df_postmortem %>% 
  ggplot(aes(y = dialysis_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  facet_wrap(~ et_program) +
  scale_color_manual(values = n2_palette, name = "Model") +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("Dialysis to Transplant Time (years)")

plot_dial_to_tx_time <- df_postmortem %>% 
  ggplot(aes(y = list_to_tx_time, x = model_name, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  scale_color_manual(values = n2_palette, name = "Model") +
  theme(legend.position = "none") +
  xlab(NULL) +
  ylab("Dialysis to Transplant Time (years)")

plot_dial_to_tx_time_by_age
plot_dial_to_tx_time_by_program
plot_dial_to_tx_time
```

```{r}
label_list <- list(
  age_recipient = "Recipient Age (years)",
  list_to_tx_time = "List to Transplant Time (years)",
  dialysis_to_tx_time = "Dialysis to Transplant Time (years)"
)

df_postmortem %>%
  select(model_name, age_recipient, list_to_tx_time, dialysis_to_tx_time) %>% 
  mutate(age_group = case_when(
    age_recipient < 18 ~ "< 18",
    age_recipient >= 18 & age_recipient < 65 ~ "18 - 65",
    age_recipient >= 65 ~ ">=65",
  )) %>% 
  select(-age_recipient) %>%
  tbl_strata(
    strata = model_name,
    .tbl_fun = 
      ~ .x %>% 
      tbl_summary(by = age_group,
              label = label_list,
              ) %>% 
      add_overall() %>% 
      modify_header(all_stat_cols() ~ "**{level}**"),
    .combine_with = "tbl_stack"
  ) %>% 
  as_gt() %>%
  tab_style(
    style = gt::cell_text(weight = "bold"),
    locations = gt::cells_row_groups(groups = everything())
  ) %>% 
  tab_spanner(label = "Age group (years)",
              columns = c(stat_1, stat_2, stat_3))
```

```{r}
plot_time_to_tx <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = list_to_tx_time)) +
  geom_point(
      size = 0.01,
      alpha = 0.01
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name) +
  theme(legend.position = "none") +
  xlab("Age (years)") +
  ylab("Listing to Transplant Time (years)") +
  ggtitle("Waitinglist time for transplanted patients",
          subtitle = "All model runs are combined")

plot_time_to_tx
```

```{r}
plot_ind_model_time_to_tx <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = list_to_tx_time)) +
  geom_point(
      size = 0.01,
      alpha = 0.01
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name + model_run_id) +
  theme(legend.position = "none") +
  xlab("Age (years)") +
  ylab("Listing to Transplant Time (years)") +
  ggtitle("Waitinglist Time for Transplanted Patients",
          subtitle = "Each model run is shown individually")

plot_ind_model_time_to_tx
```

```{r}
plot_dial_time_to_tx <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = dialysis_to_tx_time)) +
  geom_point(
      size = 0.01,
      alpha = 0.01
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name) +
  theme(legend.position = "none") +
  xlab("Age (years)")+
  ylab("Dialysis to Transplant Time (years)") +
  ggtitle("Dialysis Time for Transplanted Patients",
          subtitle = "All model runs are combined")

plot_dial_time_to_tx
```

```{r}
plot_ind_model_dial_time_to_tx <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = dialysis_to_tx_time)) +
  geom_point(
      size = 0.01,
      alpha = 0.01
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name + model_run_id) +
  theme(legend.position = "none") +
  xlab("Age (years)") +
  ylab("Dialysis to Transplant Time (years)") +
  ggtitle("Dialysis Time for transplanted patients",
          subtitle = "Each model run is shown individually")

plot_ind_model_dial_time_to_tx
```

## Age gap

```{r}
plot_age_gap <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = age_donor)) +
  geom_point(
      size = 0.01,
      alpha = 0.01
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name) +
  theme(legend.position = "none") +
  xlab("Age Recipient (years)")+
  ylab("Age Donor (years)") +
  ggtitle("Age Gap",
          subtitle = "All model runs are combined")

plot_age_gap
```

```{r}
plot_ind_model_age_gap <- df_postmortem %>% 
  ggplot(aes(x = age_recipient, y = age_donor)) +
  geom_point(
    alpha = 0.01,
      size = 0.1
    ) +
    geom_vline(
      xintercept = 65,
      colour = "red",
      size = 0.1
    ) +
  facet_wrap(~ model_name + model_run_id) +
  theme(legend.position = "none") +
  xlab("Age Recipient (years)")+
  ylab("Age Donor (years)") +
  ggtitle("Age gap",
          subtitle = "each model run is shown individually")

plot_ind_model_age_gap
```

## HLA mismatches

The median and IQR is calculated across the model runs.

```{r}
df_postmortem %>%
  select(hla_mm, et_program, model_name, model_run_id) %>% 
  group_by(model_run_id, et_program, model_name) %>% 
  summarise(
    "0" = sum(hla_mm == 0)/n() * 100,
    "1" = sum(hla_mm == 1)/n() * 100,
    "2" = sum(hla_mm == 2)/n() * 100,
    "3" = sum(hla_mm == 3)/n() * 100,
    "4" = sum(hla_mm == 4)/n() * 100,
    "5" = sum(hla_mm == 5)/n() * 100,
    "6" = sum(hla_mm == 6)/n() * 100,
    .groups = "drop"
  ) %>% 
  ungroup() %>%
  select(-c(model_run_id)) %>%
  tbl_strata(
    strata = model_name,
    .tbl_fun = 
      ~ .x %>% 
      tbl_summary(by = et_program,
              type = list(c("0",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6") ~ "continuous"),
              statistic = all_continuous() ~ "{median}% ({p25}% - {p75}%)")
  ) %>% 
  modify_header(all_stat_cols() ~ "**{level}** (Models = {n})") %>% 
  modify_footnote(all_stat_cols() ~ "Median% (IQR%)") %>% 
  modify_header(label = "**HLA MM**")
```

Mean and SD are calculated across the model runs.

```{r}
plot_hlamm <- df_postmortem %>% 
  filter(!is.na(hla_mm)) %>% 
  group_by(model_name, model_run_id, hla_mm) %>%
  summarise(count = n()) %>%
  mutate(percent = count / sum(count) * 100) %>%
  ungroup() %>% 
  group_by(model_name, hla_mm) %>% 
    summarise(
    median_perc = median(percent),
    q1_perc = quantile(percent, 0.25),
    q3_perc = quantile(percent, 0.75),
  ) %>%  
  ungroup() %>% 
  ggplot(aes(x = factor(hla_mm), y = median_perc, fill = model_name)) +
  geom_col(alpha = 0.6, width = 0.6, position = "dodge") +
    geom_errorbar(aes(ymin = q1_perc, ymax = q3_perc),
                  width = 0.3, position = position_dodge(width = 0.6)) +
  labs(y = "Percentage", x = "HLA Mismatches") +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 35)) +
  theme(legend.position = "top") +
  scale_fill_manual(values = n2_palette, name = "Model")

plot_hlamm_by_program <- df_postmortem %>% 
  filter(!is.na(hla_mm)) %>% 
  group_by(model_name, model_run_id, et_program, hla_mm) %>%
  summarise(count = n()) %>%
  mutate(percent = count / sum(count) * 100) %>%
  ungroup() %>% 
  group_by(model_name, et_program, hla_mm) %>% 
    summarise(
    median_perc = median(percent),
    q1_perc = quantile(percent, 0.25),
    q3_perc = quantile(percent, 0.75),
  ) %>%  
  ungroup() %>% 
  ggplot(aes(x = factor(hla_mm), y = median_perc, fill = model_name)) +
  geom_col(alpha = 0.6, width = 0.6, position = "dodge") +
    geom_errorbar(aes(ymin = q1_perc, ymax = q3_perc),
                  width = 0.3, position = position_dodge(width = 0.6)) +
  labs(y = "Percentage", x = "HLA Mismatches") +
  facet_wrap(~ et_program) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 35)) +
  theme(legend.position = "top") +
  scale_fill_manual(values = n2_palette, name = "Model")


plot_hlamm
plot_hlamm_by_program
```

## Waiting list

Development of waiting time and age on the waiting list.

```{r}
GetListedAtStep <- function(df, step) {
    df %>%
        filter(status_recipient != "living_donor_transplanted" &
            if_else(step_added_to_model <= step,
                if_else(step_transplanted >= step | step_removed_from_list >= step, TRUE, FALSE),
                FALSE
            )
        ) %>%
        return()
}

steps <- (0:11)*36

results_dts <- lapply(steps, function(step) {
  df_dts %>%
    group_by(model_name) %>% 
    GetListedAtStep(step) %>%
    mutate(
      # time difference has to be calculated, since age, waiting time etc.
      # increases until the step of removal, transplantation etc.
      time_difference = (if_else(!is.na(step_transplanted),
                                      step_transplanted - step,
                                      if_else(!is.na(step_removed_from_list),
                                              step_removed_from_list - step,
                                              0)
                                      )
                              ) * step_size,
      age = age_recipient - time_difference,
           waitinglist_time = waitinglist_time - time_difference,
           dialysis_time = dialysis_time - time_difference) %>%
    summarise(
      across(c(age, waitinglist_time, dialysis_time),
               ~ MedianIQR(.x, nsmall = 1, digits = 1),
      .names = "{.col}_median_iqr")) %>% 
    mutate(date = as.Date("2006-01-01") + years(step * step_size), .before = age_median_iqr)
})

final_table_dts <- bind_rows(results_dts) %>% 
  pivot_wider(names_from = model_name,
              values_from = c(age_median_iqr, waitinglist_time_median_iqr, dialysis_time_median_iqr))

final_table_dts %>% 
  select(date, contains("median_iqr")) %>% 
  gt() %>%
    cols_label(
      contains("date") ~ "Date",
      contains("age") ~ "Age",
      contains("waitinglist") ~ "Waiting List Time",
      contains("dialysis") ~ "Dialysis Time",
    ) %>%
    cols_align(align = "center", columns = everything()) %>%
  tab_spanner(
    label = "ESP Omitted",
    columns = contains("ESP Omitted")
  ) %>% 
  tab_spanner(
    label = "No Changes",
    columns = contains("No Changes")
  ) %>% 
  tab_footnote(
    footnote = "Median (IQR)",
    locations = cells_column_labels(
      columns = contains("median_iqr")
    )
  )
```

## Post transplant risk

```{python}
from kidney_dtsim.post_transplant_risk_helpers import *

spline_dwfg = pd.read_csv("../data/model_input/CTS_spline_data_dwfg_10000_days.txt", sep= "\t").set_index("time")
spline_gf = pd.read_csv("../data/model_input/CTS_spline_data_gf_10000_days.txt", sep= "\t").set_index("time")

# parameters for cumulative_hazard_gf
parameters_gf = {
"_parametercons": -1.6966,
"_parameterdonor_age": 0.01428,
"_parameterda_2": 0.000116,
"_parameterrec_age": -0.04430,
"_parameterra_2": 0.000320,
"_parameterrcs1": 1.2120,
"_parameterrcs2": -0.2006,
"_parameterrcs3": -0.1639,
"_parameterrcs_rec_age1": -0.01538,
"_parameterrcs_rec_age2": 0.000068,
"_parameterrcs_ra_21": 0.000135,
"_parameterrcs_ra_22": 9.411E-6
}

# parameters for cumulative_hazard_dwfg
parameters_dwfg = {
"_parametercons": -6.0350,
"_parameterdonor_age": 0.004303,
"_parameterrec_age": 0.06132,
"_parameterrcs1": 1.0725,
"_parameterrcs2": -0.01509,
"_parameterrcs3": -0.1327,
"_parameterrcs_rec_age1": 0.005070,
"_parameterrcs_rec_age2": -0.00389
}
```

```{r}
generate_dialysis_free_surv <- function(data) {
  # Generate dialysis free survival time and event
  data <- data %>% 
    mutate(
    dialysis_free_survival_time = case_when(
      event_graft_failure == 1 &
        event_death == 1 ~ pmin(time_graft_failure, time_death),
      event_graft_failure == 1 ~ time_graft_failure,
      event_death == 1 ~ time_death,
      TRUE ~ pmin(time_graft_failure, time_death)),
    event_composite_gf_death = if_else(event_graft_failure == 1 |
                                         event_death == 1, 1, 0)
    )
  return(data)
  }

risks <- py$calc_risks(
  donor_ages = df_postmortem$age_donor,
  recipient_ages = df_postmortem$age_recipient,
  spline_gf = py$spline_gf,
  spline_dwfg = py$spline_dwfg,
  parameters_gf = py$parameters_gf,
  parameters_dwfg = py$parameters_dwfg,
  pred_dial_free_surv_time = TRUE,
  pred_death_time = TRUE,
  pred_gf_time = TRUE,
  t_max = 10000
)

# The mean survival probabilities are extracted from the results
mean_surv_probs <- risks$mean_survival_probs
time_range <- seq(1, length(mean_surv_probs))

df_mean_surv_probs <- data.frame(
  time = time_range,
  mean_survival_prob = mean_surv_probs
)

df_postmort_surv <- cbind(df_postmortem, risks$df_post_tx_risk)
```

```{r}
generate_surv_plot <- function(data,
                               time_col,
                               event_col,
                               ylab_label,
                               xlim = c(0, 365.25 * 27),
                               x_break_by = 365.25 * 5) {
  
  # Capture the column names correctly
  time_col <- substitute(time_col)
  event_col <- substitute(event_col)
  
  # Construct the survival formula dynamically using substitute
  survival_formula <- as.formula(bquote(Surv(.(time_col), .(event_col)) ~ model_name))

  # Fit survival model
  fit <- survfit2(survival_formula, data = data)
  
  fit %>%
    ggsurvfit() +
    add_censor_mark(size = 1, alpha = 0.1) +
    add_risktable(
      risktable_stats = "{n.risk} ({cum.event})",
      risktable_height = 0.2,
      size = rel(0.6) * .pt,
      color = "grey30",
      theme =
        list(theme_risktable_default(plot.title.size = rel(0.6)))
    ) +
    add_risktable_strata_symbol(symbol = "-", vjust = 0.4) +
    add_confidence_interval() +
    theme_nassim() +
    theme(legend.position = "top" , legend.key.size = unit(rel(1) * .pt, "mm")
          ) +
    scale_fill_manual(values = n2_palette) +
    scale_color_manual(values = n2_palette, guide = guide_legend(nrow = 1)) +
    scale_ggsurvfit(
      x_scales = list(
        name = "Waiting Time in Years",
        breaks = seq(0, 365.25 * 25, by = x_break_by),
        labels = seq(0, 25, by = x_break_by / 365.25),
        limits = xlim,
        expand = expansion(mult = c(0.1, 0))
      )
    ) +
    labs(y = ylab_label) +
    coord_cartesian(clip = "off")
}
```

```{r}
df_postmort_surv <- df_postmort_surv %>%
  mutate(event_pred_comp_death_gf = if_else(pred_dialysis_free_surv_time < 9997, 1, 0),
         event_pred_gf = if_else(pred_gf_time < 9997, 1, 0),
         event_pred_death = if_else(pred_death_time < 9997, 1, 0))

df_combined_pred_obs <- df_postmort_surv %>%
  select(
    model_name,
    pred_dialysis_free_surv_time,
    event_pred_comp_death_gf
  ) %>%
  rename(event = event_pred_comp_death_gf,
         time = pred_dialysis_free_surv_time)

plot_dial_free_surv <-  df_combined_pred_obs %>%
  generate_surv_plot(
    time,
    event,
    "Dialysis Free Survival Probability"
  )

plot_gf_surv <-  df_postmort_surv %>%
  generate_surv_plot(
    pred_gf_time,
    event_pred_gf,
    "Graft Survival Probability"
  )

plot_surv <- df_postmort_surv %>%
  generate_surv_plot(
    pred_death_time,
    event_pred_death,
    "Survival Probability"
  )

plot_dial_free_surv
plot_gf_surv
plot_surv
```

### Cumulative survival times

One has to keep in mind, that the maximum survival time can only be 10000 days, since the model can only predict up to this time point. Thus I would say the cumulative survival time is only meaningful when the survival probability goes next to 0 at 10000 days.

```{r}
cum_survival <- df_postmort_surv %>% 
  group_by(model_name, model_run_id) %>% 
  summarise(
    cum_dialysis_free_surv_time = sum(pred_dialysis_free_surv_time, na.rm = TRUE)/365.25/n(),
            cum_gf_time = sum(pred_gf_time, na.rm = TRUE)/365.25/n(),
            cum_death_time = sum(pred_death_time, na.rm = TRUE)/365.25/n()) %>% 
  ungroup()

cum_survival %>% 
  group_by(model_name) %>%
  summarise(across(contains("cum_"),
                   .fns = list(
                     medianiqr = ~ MedianIQR(.x, digits = 1, nsmall = 1),
                     median = ~ median(.x, na.rm = TRUE),
                     q1 = ~ quantile(.x, 0.25, na.rm = TRUE),
                     q3 = ~ quantile(.x, 0.75, na.rm = TRUE)
                   ))) %>% 
  select("model_name", contains("medianiqr")) %>% 
  gt() %>% 
  cols_label(
    "model_name" ~ "Model",
    "cum_dialysis_free_surv_time_medianiqr" ~ "Dialysis Free Survival Time",
    "cum_gf_time_medianiqr" ~ "Graft Survival Time",
    "cum_death_time_medianiqr" ~ "Survival Time") %>% 
  tab_footnote(
    footnote = "Cumulative Time per Transplantation in Years: Median (IQR)", locations = cells_column_labels(columns = -contains("model_name"))
    )
```

```{r}
cum_survival %>% 
  ggplot(aes(x = model_name, y = cum_dialysis_free_surv_time, color = model_name)) +
    geom_boxplot() +
  scale_color_manual(values = n2_palette) +
  xlab(NULL) +
  ylab(label = "Cum Dialysis Free Survival Time per Transplantation (years)") +
  scale_y_continuous(limits = c(0, NA)) +
  theme(legend.position = "none")

cum_survival %>% 
  ggplot(aes(x = model_name, y = cum_gf_time, color = model_name)) +
    geom_boxplot() +
  scale_color_manual(values = n2_palette) +
  xlab(NULL) +
  ylab("Cum Graft Survival Time per Transplantation (years)") +
  scale_y_continuous(limits = c(0, NA)) +
  theme(legend.position = "none")

cum_survival %>% 
  ggplot(aes(x = model_name, y = cum_death_time, color = model_name)) +
    geom_boxplot() +
  scale_color_manual(values = n2_palette) +
  xlab(NULL) +
  ylab("Cum Survival Time per Transplantation (years)") +
  scale_y_continuous(limits = c(0, NA)) +
  theme(legend.position = "none")
```

### Cumulative Incidences

Hazard driven calculation of cumulative incidences. These are slightly different than the empirical cumulative incidences and the simulated survival times in the Kaplan-Meier curve.

```{r}
df_postmort_surv %>%
  group_by(model_name) %>%
  summarise(
    across(c(
      pred_cum_inc_comp_5y,
      pred_cum_inc_dwfg_5y,
             pred_cum_inc_gf_5y,
      pred_cum_inc_comp_10y,
             pred_cum_inc_dwfg_10y,
             pred_cum_inc_gf_10y),
           list(medianiqr = ~ paste0(format(median(.x)*100, digits = 1, nsmall = 1, trim = TRUE),
                                    "% (",
                                    format(quantile(.x, 0.25)*100, digits = 1, nsmall = 1, trim = TRUE),
                                    "%, ",
                                    format(quantile(.x, 0.75)*100, digits = 1, nsmall = 1, trim = TRUE),
                                    "%)")
                )
           )
  ) %>% 
  gt() %>% 
  cols_label(
    "model_name" ~ "Model",
    "pred_cum_inc_comp_5y_medianiqr" ~ "Death or Graft Failure",
    "pred_cum_inc_dwfg_5y_medianiqr" ~ "Death With Functioning Graft",
    "pred_cum_inc_gf_5y_medianiqr" ~ "Graft Failure",
    "pred_cum_inc_comp_10y_medianiqr" ~ "Death or Graft Failure",
    "pred_cum_inc_dwfg_10y_medianiqr" ~ "Death With Functioning Graft",
    "pred_cum_inc_gf_10y_medianiqr" ~ "Graft Failure") %>% 
  tab_spanner(
    label = "5 Year Cumulative Incidence",
    columns = contains("5y")
  ) %>% 
  tab_spanner(
    label = "10 Year Cumulative Incidence",
    columns = contains("10y")
  )
```

Per-run empirical cumulative incidence. Median and IQR are reported across the different simulation runs.

```{r}
emp_cum_inc <- df_postmort_surv %>% 
  group_by(model_name, model_run_id) %>% 
  summarise(
    empirical_cum_inc_comp_10y = mean(pred_dialysis_free_surv_time <= 3652.5),
    empirical_cum_inc_dwfg_10y = mean(pred_death_time <= 3652.5),
    empirical_cum_inc_gf_10y = mean(pred_gf_time <= 3652.5)
  )

emp_cum_inc %>% 
  group_by(model_name) %>% 
  summarise(
    empirical_cum_inc_comp_10y = MedianIQR(empirical_cum_inc_comp_10y * 100, percentage = TRUE, digits = 1),
    empirical_cum_inc_dwfg_10y = MedianIQR(empirical_cum_inc_dwfg_10y * 100, percentage = TRUE, digits = 1),
    empirical_cum_inc_gf_10y = MedianIQR(empirical_cum_inc_gf_10y * 100, percentage = TRUE, digits = 1)
  ) %>% 
  gt() %>% 
  cols_label(
    "model_name" ~ "Model",
    "empirical_cum_inc_comp_10y" ~ "Death or Graft Failure",
    "empirical_cum_inc_dwfg_10y" ~ "Death With Functioning Graft",
    "empirical_cum_inc_gf_10y" ~ "Graft Failure") %>% 
  tab_spanner(
    label = "10 Year Cumulative Incidence",
    columns = contains("10y")
  )
```

```{r}
plot_cum_inc_boxplot <- function(data, colname, ylab_text){
  data %>% 
  ggplot(aes(x = model_name, y = {{colname}} * 100, color = model_name)) +
  geom_boxplot(outliers = FALSE) +
  scale_color_manual(values = n2_palette) +
  xlab(NULL) +
  scale_y_continuous(limits = c(0, NA), labels = ~ paste0(.x, "%")) +
  ylab(ylab_text) +
  theme(legend.position = "none")
}
```

#### 10 Years
Based on the empirical cumulative incidences from simulated survival times, across the simulation runs.

```{r}
plot_cum_inc_comp_10y <- emp_cum_inc %>% 
  plot_cum_inc_boxplot(empirical_cum_inc_comp_10y,
                       "10-Year Cumulative Incidence of Graft Failure or Death")

plot_cum_inc_dwfg_10y <- emp_cum_inc %>% 
  plot_cum_inc_boxplot(empirical_cum_inc_dwfg_10y,
                       "10-Year Cumulative Incidence of Death with Functioning Graft")

plot_cum_inc_gf_10y <- emp_cum_inc %>% 
  plot_cum_inc_boxplot(empirical_cum_inc_gf_10y,
                       "10-Year Cumulative Incidence of Graft Failure")

plot_cum_inc_comp_10y
plot_cum_inc_dwfg_10y
plot_cum_inc_gf_10y
```

## Figures

```{r}
fig <- plot_grid(
  plot_grid(
    plot_model_development,
    plot_rec_age_dist,
    nrow = 1,
    labels = c("A", "B"),
    label_size = 12,
    label_x = c(-0.015, 0)
    ),
  plot_grid(
    plot_hlamm +
      theme(legend.key.size = unit(8, "points")),
    plot_dial_to_tx_time_by_age,
    plot_cum_inc_comp_10y,
    nrow = 1,
    labels = c("C", "D", "E"),
    rel_widths = c(1, 2, 1),
    label_size = 12,
    label_x = c(-0.015, 0.1, -0.1)
  ),
  nrow = 2
)

# Add blank area below figure and add label
plot_grid(fig,
          NULL,
          rel_heights = c(1, 0.05),
          ncol = 1) +
  draw_label(
    label = "Figure 4",
    x = 1,
    y = 0,
    hjust = 1.1,
    vjust = -0.3,
    fontface = "bold",
    size = 12
  )
```


```{r}
plot_grid(
  plot_dial_time_to_tx,
  plot_age_gap,
  plot_time_to_tx,
  labels = "AUTO",
  label_size = 12
)
```


```{r}
plot_grid(
  plot_grid(
    ggsurvfit_build(plot_dial_free_surv),
    NULL,
    nrow = 1,
    rel_widths = c(3,1),
    labels = c("A", ""),
    label_size = 12
    ),
  plot_grid(
    ggsurvfit_build(plot_gf_surv),
    plot_cum_inc_gf_10y,
    nrow = 1,
    rel_widths = c(3,1),
    labels = c("B", "C"),
    label_size = 12
    ),
  plot_grid(
    ggsurvfit_build(plot_surv),
    plot_cum_inc_dwfg_10y,
    nrow = 1,
    rel_widths = c(3,1),
    labels = c("D", "E"),
    label_size = 12
  ),
  ncol = 1
)
```

